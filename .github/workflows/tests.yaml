name: Chaos tests

on:
  workflow_call:
    inputs:
      weaviate_version:
        required: true
        type: string
      lsm_access_strategy:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      GCP_SERVICE_ACCOUNT_BENCHMARKS:
        required: true
      POLARSIGNALS_TOKEN:
        required: true

env:
  WEAVIATE_VERSION: ${{ inputs.weaviate_version }}
  DISABLE_RECOVERY_ON_PANIC: true

jobs:
  real-version-in-tag:
    name: "Retrieve the real version from the image tag"
    runs-on: ubuntu-latest
    env:
      WEAVIATE_VERSION: ${{ inputs.weaviate_version }}
    outputs:
      real_version: ${{ steps.weaviate-version-from-image.outputs.weaviate_version }}
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Retrieve the weaviate version from the image
        uses: weaviate/github-common-actions/.github/actions/weaviate-version-in-image@main
        id: weaviate-version-from-image
        with:
          image_tag: ${{ env.WEAVIATE_VERSION }}
  equal-to-1_24:
    name: "Check if the version is equal to 1.24"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.24.0"
          operator: "="
  newer-or-equal-than-1_24:
    name: "Check if the version is newer than 1.24"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.24.0"
          operator: ">="
  newer-or-equal-than-1_25:
    name: "Check if the version is newer than 1.25"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.25.0"
          operator: ">="
  newer-or-equal-than-1_26:
    name: "Check if the version is newer than 1.26"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.26.0"
          operator: ">="
  newer-or-equal-than-1_28:
    name: "Check if the version is newer than 1.28"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.28.0"
          operator: ">="
  newer-or-equal-than-1_29:
    name: "Check if the version is newer than 1.29"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.29.0"
          operator: ">="
  newer-or-equal-than-1_30:
    name: "Check if the version is newer than 1.30"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.30.0"
          operator: ">="
  older-than-1_30:
    name: "Check if the version is older than 1.30"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.30.0"
          operator: "<"
  newer-or-equal-than-1_31:
    name: "Check if the version is newer than 1.31"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.31.0"
          operator: ">="
  newer-or-equal-than-1_32:
    name: "Check if the version is newer than 1.32"
    needs: real-version-in-tag
    runs-on: ubuntu-latest
    outputs:
      check: ${{ steps.semver_compare.outputs.result }}
    steps:
      - name: Semver Compare
        id: semver_compare
        uses: fabriziocacicia/semver-compare-action@v0.1.0
        with:
          first: ${{ needs.real-version-in-tag.outputs.real_version }}
          second: "1.32.0-dev"  # TODO: change to 1.32.0 when the version is released
          operator: ">="
  filter-memory-leak:
    name: Filter (cache) memory leak when querying while importing
    if: ${{ github.event.inputs.test_to_run == 'filter-memory-leak' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./filter_memory_leak.sh
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: psf/black@stable
  ann-benchmarks-sift-aws:
    name: "[bench AWS] SIFT1M pq=false"
    if: ${{ github.event.inputs.test_to_run == 'ann-benchmarks-sift-aws' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: sift-128-euclidean
      DISTANCE: l2-squared
      REQUIRED_RECALL: 0.999
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-glove-aws:
    name: "[bench AWS] Glove100 pq=false"
    if: ${{ github.event.inputs.test_to_run == 'ann-benchmarks-glove-aws' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: glove-100-angular
      DISTANCE: cosine
      REQUIRED_RECALL: 0.965
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-pq-sift-aws:
    name: "[bench AWS] SIFT1M pq=true"
    if: ${{ github.event.inputs.test_to_run == 'ann-benchmarks-pq-sift-aws' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: sift-128-euclidean
      DISTANCE: l2-squared
      REQUIRED_RECALL: 0.992
      QUANTIZATION: pq
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-sq-sift-aws:
    needs: [newer-or-equal-than-1_26]
    if: ${{ (needs.newer-or-equal-than-1_26.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-sq-sift-aws' || github.event.inputs.test_to_run == '')}}
    name: "[bench AWS] SIFT1M sq=true"
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: sift-128-euclidean
      DISTANCE: l2-squared
      REQUIRED_RECALL: 0.992
      QUANTIZATION: sq
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-pq-glove-aws:
    name: "[bench AWS] Glove100 pq=true"
    if: ${{ github.event.inputs.test_to_run == 'ann-benchmarks-pq-glove-aws' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: glove-100-angular
      DISTANCE: cosine
      REQUIRED_RECALL: 0.89
      QUANTIZATION: pq
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-sq-glove-aws:
    needs: [newer-or-equal-than-1_26]
    if: ${{ (needs.newer-or-equal-than-1_26.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'ann-benchmarks-sq-glove-aws' || github.event.inputs.test_to_run == '' ) }}
    name: "[bench AWS] Glove100 sq=true"
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: glove-100-angular
      DISTANCE: cosine
      REQUIRED_RECALL: 0.89
      QUANTIZATION: sq
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'

  ann-benchmarks-rq-glove-aws:
    needs: [newer-or-equal-than-1_32]
    if: ${{ (needs.newer-or-equal-than-1_32.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-rq-glove-aws' || github.event.inputs.test_to_run == '') }}
    name: "[bench AWS] Glove100 rq=true"
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.AWS_ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.AWS_SECRET_ACCESS_KEY}}
      DATASET: glove-100-angular
      DISTANCE: cosine
      REQUIRED_RECALL: 0.89
      QUANTIZATION: rq
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_aws.sh
      - name: Cleanup AWS resources
        if: always()
        run: ./cleanup_aws_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'


  ann-benchmarks-sift-gcp:
    name: "[bench GCP] SIFT1M pq=false"
    if: ${{ github.event.inputs.test_to_run == 'ann-benchmarks-sift-gcp' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: sift-128-euclidean
      DISTANCE: l2-squared
      REQUIRED_RECALL: 0.999
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 20GB
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_gcp.sh
      - name: Cleanup GCP resources
        if: ${{ always() || cancelled() }}
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-pq-sift-gcp:
    name: "[bench GCP] SIFT1M pq=true"
    if: ${{ github.event.inputs.test_to_run == 'ann-benchmarks-pq-sift-gcp' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: sift-128-euclidean
      DISTANCE: l2-squared
      REQUIRED_RECALL: 0.992
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 20GB
      QUANTIZATION: pq
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'

  ann-benchmarks-rq-sift-gcp:
    needs: [newer-or-equal-than-1_32]
    if: ${{ (needs.newer-or-equal-than-1_32.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-rq-sift-gcp' || github.event.inputs.test_to_run == '') }}
    name: "[bench GCP] SIFT1M rq=true"
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: sift-128-euclidean
      DISTANCE: l2-squared
      REQUIRED_RECALL: 0.992
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 20GB
      QUANTIZATION: rq
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'



  ann-benchmarks-multivector-gcp:
    name: "[bench GCP] MULTIVECTOR3M"
    needs: [newer-or-equal-than-1_29]
    if: ${{ (needs.newer-or-equal-than-1_29.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-multivector-gcp' || github.event.inputs.test_to_run == '' || github.event.inputs.test_to_run == 'ann-benchmarks-multivector-all') }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: lotte-recreation-reduced-vl-50000
      DISTANCE: dot
      REQUIRED_RECALL: 0.992
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 20GB
      MULTIVECTOR_DATASET: true
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'          
  ann-benchmarks-multivector-pq-gcp:
    name: "[bench GCP] MULTIVECTOR3M pq=true"
    needs: [newer-or-equal-than-1_30]
    if: ${{ (needs.newer-or-equal-than-1_30.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-multivector-pq-gcp' || github.event.inputs.test_to_run == '' || github.event.inputs.test_to_run == 'ann-benchmarks-multivector-all') }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: lotte-recreation-reduced-vl-50000
      DISTANCE: dot
      REQUIRED_RECALL: 0.990
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 40GB
      MULTIVECTOR_DATASET: true
      QUANTIZATION: pq
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'      
  ann-benchmarks-multivector-sq-gcp:
    name: "[bench GCP] MULTIVECTOR3M sq=true"
    needs: [newer-or-equal-than-1_30]
    if: ${{ (needs.newer-or-equal-than-1_30.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-multivector-sq-gcp' || github.event.inputs.test_to_run == '' || github.event.inputs.test_to_run == 'ann-benchmarks-multivector-all') }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: lotte-recreation-reduced-vl-50000
      DISTANCE: dot
      REQUIRED_RECALL: 0.990
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 40GB
      MULTIVECTOR_DATASET: true
      QUANTIZATION: sq
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'
  ann-benchmarks-multivector-rq-gcp:
    name: "[bench GCP] MULTIVECTOR3M rq=true"
    needs: [newer-or-equal-than-1_32]
    if: ${{ (needs.newer-or-equal-than-1_32.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-multivector-rq-gcp' || github.event.inputs.test_to_run == '' || github.event.inputs.test_to_run == 'ann-benchmarks-multivector-all') }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: lotte-recreation-reduced-vl-50000
      DISTANCE: dot
      REQUIRED_RECALL: 0.95
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 40GB
      MULTIVECTOR_DATASET: true
      QUANTIZATION: rq
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh
      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'

  ann-benchmarks-multivector-muvera-gcp:
    name: "[bench GCP] MULTIVECTOR MUVERA"
    needs: [newer-or-equal-than-1_31]
    if: ${{ (needs.newer-or-equal-than-1_31.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-multivector-muvera-gcp' || github.event.inputs.test_to_run == '' || github.event.inputs.test_to_run == 'ann-benchmarks-multivector-all') }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: lotte-recreation-reduced-vl-50000
      DISTANCE: dot
      REQUIRED_RECALL: 0.80
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 20GB
      MULTIVECTOR_DATASET: true
      MULTIVECTOR_IMPLEMENTATION: muvera
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'
      - name: Run chaos test
        if: always()
        run: ./ann_benchmark_gcp.sh

      - name: Run chaos test with PQ
        if: always()
        env:
          QUANTIZATION: pq
        run: ./ann_benchmark_quantization_gcp.sh

      - name: Run chaos test with SQ
        if: always()
        env:
          QUANTIZATION: sq
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh

      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'


  ann-benchmarks-multivector-muvera-gcp-rq:
    name: "[bench GCP] MULTIVECTOR MUVERA and RQ"
    needs: [newer-or-equal-than-1_32]
    if: ${{ (needs.newer-or-equal-than-1_32.outputs.check == 'true') && (github.event.inputs.test_to_run == 'ann-benchmarks-multivector-muvera-gcp-rq' || github.event.inputs.test_to_run == '' || github.event.inputs.test_to_run == 'ann-benchmarks-multivector-all') }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      DATASET: lotte-recreation-reduced-vl-50000
      DISTANCE: dot
      REQUIRED_RECALL: 0.80
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      BOOT_DISK_SIZE: 20GB
      MULTIVECTOR_DATASET: true
      MULTIVECTOR_IMPLEMENTATION: muvera
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - id: 'gcs_auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_BENCHMARKS}}
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v1'

      - name: Run chaos test with RQ
        if: always()
        env:
          QUANTIZATION: rq
        run: ./ann_benchmark_quantization_gcp.sh
      - name: Cleanup GCP resources
        if: always()
        run: ./cleanup_gcp_resources.sh

      - id: 'upload-files'
        uses: 'google-github-actions/upload-cloud-storage@v1'
        with:
          path: 'results'
          destination: 'ann-pipelines/github-action-runs'
          glob: '*.json'

  batch-import-many-classes:
    name: One class receives long and expensive batches, user tries to create and delete 100s of classes in parallel
    if: ${{ github.event.inputs.test_to_run == 'batch-import-many-classes' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./batch_import_many_classes.sh
  upgrade-journey:
    name: Rolling updates in single-node setup from min to target version
    if: ${{ github.event.inputs.test_to_run == 'upgrade-journey' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      NUM_NODES: 1
      MINIMUM_WEAVIATE_VERSION: 1.22.0
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.23'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./upgrade_journey.sh
  upgrade-journey-cluster:
    name: Rolling updates in multi-node setup from min to target version
    if: ${{ github.event.inputs.test_to_run == 'upgrade-journey-cluster' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      NUM_NODES: 3
      MINIMUM_WEAVIATE_VERSION: 1.22.0
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.23'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./upgrade_journey.sh
  replicated-imports-with-choas-killing:
    name: Replicated imports with chaos killing
    if: ${{ github.event.inputs.test_to_run == 'replicated-imports-with-choas-killing' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-8-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      #- name: Setup tmate session
      #uses: mxschmitt/action-tmate@v3
      - name: Run chaos test
        run: ./replication_importing_while_crashing.sh
  replicated-imports-with-backup:
    name: Replicated imports with backup loop
    if: ${{ github.event.inputs.test_to_run == 'replicated-imports-with-backup' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-4-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./replication_importing_with_backup.sh
  replication-tunable-consistency:
    name: Replication tunable consistency
    if: ${{ github.event.inputs.test_to_run == 'replication-tunable-consistency' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-8-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./replication_tunable_consistency.sh
  counting-while-compacting:
    name: Counting while compacting
    if: ${{ github.event.inputs.test_to_run == 'counting-while-compacting' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-8-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./counting_while_compacting.sh
  segfault-on-batch-ref:
    name: Segfault on batch ref
    if: ${{ github.event.inputs.test_to_run == 'segfault-on-batch-ref' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./segfault_batch_ref.sh
  import-with-kills:
    name: Import during constant kills/crashes
    if: ${{ github.event.inputs.test_to_run == 'import-with-kills' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-4-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./import_while_crashing.sh
  heavy-imports-crashing:
    name: Heavy object store imports while crashing
    if: ${{ github.event.inputs.test_to_run == 'heavy-imports-crashing' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-8-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./import_while_crashing_no_vector.sh
  segfault-filtered-search:
    name: Segfault on filtered vector search (race with hash bucket compaction)
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'segfault-filtered-search' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./segfault_filtered_vector_search.sh
  backup-restore-crud:
    name: Backup & Restore CRUD
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'backup-restore-crud' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./backup_and_restore_crud.sh
  backup-restore-crud-multi-node:
    name: Backup & Restore multi node CRUD
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'backup-restore-crud-multi-node' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./backup_and_restore_multi_node_crud.sh
  backup-restore-version-compat:
    name: Backup & Restore version compatibility
    runs-on: ubuntu-latest-8-cores
    if: ${{ github.event.inputs.test_to_run == 'backup-restore-version-compat' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./backup_and_restore_version_compatibility.sh
  compare-recall:
    name: Compare Recall after import to after restart
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'compare-recall' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./compare_recall_after_restart.sh
  concurrent-read-write:
    name: Concurrent inverted index read/write
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'concurrent-read-write' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./concurrent_inverted_index_read_write.sh
  consecutive-create-update:
    name: Consecutive create and update operations
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'consecutive-create-update' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./consecutive_create_and_update_operations.sh
  batch-insert-mismatch:
    name: Batch insert mismatch
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'batch-insert-mismatch' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./consecutive_create_and_update_operations.sh
  rest-patch-restart:
    name: REST PATCH requests stop working after restart
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'rest-patch-restart' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./rest_patch_stops_working_after_restart.sh
  delete-recreate-updates:
    name: Delete and recreate class with frequent updates
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'delete-recreate-updates' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./delete_and_recreate_class.sh
  deletes-with_node-out-of-sync:
    # Fixed in 1.24.18 and 1.25.4
    name: Delete objects with CL ONE on a node out of sync
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'deletes-with_node-out-of-sync' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./deletes_with_node_out_of_sync.sh
  geo-crash:
    name: Preventing crashing of geo properties during HNSW maintenance cycles
    if: ${{ github.event.inputs.test_to_run == 'geo-crash' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-8-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./geo_crash.sh
  compaction-roaringset:
    name: Preventing panic on compaction of roaringsets
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'compaction-roaringset' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./compaction_roaringset.sh
  multi-node-references:
    name: Large batches with many cross-refs on a multi-node cluster
    runs-on: ubuntu-latest-4-cores
    if: ${{ github.event.inputs.test_to_run == 'multi-node-references' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./multi_node_ref_imports.sh
  multi-tenancy-concurrent-imports:
    name: Concurrent clients importing into multi-node cluster
    if: ${{ github.event.inputs.test_to_run == 'multi-tenancy-concurrent-imports' || github.event.inputs.test_to_run == '' }}
    runs-on: ubuntu-latest-8-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./multi_tenancy_concurrent_importing.sh
  multi_tenancy_activate_deactivate_v1_24:
    needs: [equal-to-1_24]
    if: ${{ (needs.equal-to-1_24.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'multi_tenancy_activate_deactivate_v1_24' || github.event.inputs.test_to_run == '') }}
    name: Activate and deactivate tenants' shards (v1.24 only)
    runs-on: ubuntu-latest-4-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./multi_tenancy_activate_deactivate_v1_24.sh
  multi_tenancy_activate_deactivate:
    needs: [newer-or-equal-than-1_25]
    if: ${{ (needs.newer-or-equal-than-1_25.outputs.check ) && ( github.event.inputs.test_to_run == 'multi_tenancy_activate_deactivate' || github.event.inputs.test_to_run == '') }}
    name: Activate and deactivate tenants' shards
    runs-on: ubuntu-latest-4-cores
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./multi_tenancy_activate_deactivate.sh
  goroutine_leak_class_delete:
    name: Check for degraded performance from goroutine leak on class delete
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'goroutine_leak_class_delete' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./goroutine_leak_on_class_delete.sh
  bm25_corruption:
    name: Validate that the BM25 (and other indexes) index does not corrupt when crashes occur during batch delete
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'bm25_corruption' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./bm25_corruption.sh
  backup_and_flush:
    # https://github.com/weaviate/weaviate/issues/4418
    name: Test that flushing is reestablished after a backup is performed
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'backup_and_flush' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./backup_and_flush.sh
  backup_and_restore_out_of_sync:
    # https://github.com/weaviate/weaviate/pull/4541
    name: Test that restoring a backup without data presence ensures schema consistency across nodes
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'backup_and_restore_out_of_sync' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./backup_and_restore_multi_node_out_of_sync.sh
  # Commented only because this chaos pipeline was able to interrupt save operation
  # just in the middle of it being performed and since Weaviate doesn't have a transaction
  # mechanism implemented then this was causing an error which is a different error then
  # the discrepancy one, but this pipeline is really good in crashing Weaviate so we want to
  # save it for future tests
  # compare-while-crashing:
  #   name: Compare REST and GraphQL while crashing
  #   runs-on: ubuntu-latest-4-cores
  #   steps:
  #     - uses: actions/checkout@v3
  #     - name: Login to Docker Hub
  #       uses: docker/login-action@v3
  #       with:
  #         username: ${{secrets.DOCKER_USERNAME}}
  #         password: ${{secrets.DOCKER_PASSWORD}}
  #     - name: Run chaos test
  #       run: ./compare_rest_graphql_while_crashing.sh
  upgrade-journey-single-node-cluster:
    needs: [newer-or-equal-than-1_25]
    if: ${{ (needs.newer-or-equal-than-1_25.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'upgrade-journey-single-node-cluster' || github.event.inputs.test_to_run == '') }}
    name: Upgrade journey for RAFT single node cluster
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      NUM_NODES: 1
      MINIMUM_WEAVIATE_VERSION: 1.25.0
    steps:
      - uses: actions/checkout@v3
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.20'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./upgrade_single_node_journey.sh
  upgrade-journey-raft:
    needs: [newer-or-equal-than-1_25, older-than-1_30]
    if: ${{ (needs.newer-or-equal-than-1_25.outputs.check == 'true') && ((needs.older-than-1_30.outputs.check == 'true')) && ( github.event.inputs.test_to_run == 'upgrade-journey-raft' || github.event.inputs.test_to_run == '')}}
    name: Upgrade to Raft journey e2e test
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      WEAVIATE_NON_RAFT_VERSION: 1.24.15
      WEAVIATE_RAFT_VERSION_1: 1.25.0
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      PERSISTENCE_MAX_REUSE_WAL_SIZE: 0  # disable WAL reuse, otherwise pipeline will fail because of an unknown commit type (CommitTypeRoaringSetList) that was added in 1.25
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Install python dependencies
        run: |
          cd apps/upgrade-journey-raft
          pip3 install -r requirements.txt
      - name: Weaviate v1.24.x - setup K8s 3-node cluster
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'setup'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_NON_RAFT_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set podManagementPolicy=OrderedReady --set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.PERSISTENCE_MAX_REUSE_WAL_SIZE=${{env.PERSISTENCE_MAX_REUSE_WAL_SIZE}}' 
      - name: Weaviate v1.24.x - import data
        run: |
          cd apps/upgrade-journey-raft
          python3 run.py
      - name: Weaviate v1.24.x - check data after import
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py
      - name: Weaviate v1.25.0 - upgrade K8s cluster from non-raft to Raft version
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_RAFT_VERSION_1}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.PERSISTENCE_MAX_REUSE_WAL_SIZE=${{env.PERSISTENCE_MAX_REUSE_WAL_SIZE}}'
          delete-sts: 'true'
      - name: Weaviate v1.25.0 - check data after upgrade to Raft version
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py
      - name: Weaviate preview image - upgrade K8s from Raft to another Raft version (rolling update)
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.PERSISTENCE_MAX_REUSE_WAL_SIZE=${{env.PERSISTENCE_MAX_REUSE_WAL_SIZE}}'
      - name: Weaviate preview image - check old data
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py
      - name: Weaviate preview image - add additional data and check all (old and new) data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_run.py
          python3 additional_checks.py
      - name: Weaviate preview image - sync with schema V1
        run: |
          if [ "$(curl -X POST -s -o /dev/null -w "%{http_code}" localhost:8080/v1/cluster/schema-v1)" != "200" ]; then
            echo "Synchronization of schema V1 failed"
            exit 1
          else
            echo "Schema V1 succesfully synchronized"
          fi
      - name: Weaviate v1.24.x - downgrade from Raft to none-raft version
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_NON_RAFT_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set podManagementPolicy=OrderedReady  --set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.PERSISTENCE_MAX_REUSE_WAL_SIZE=${{env.PERSISTENCE_MAX_REUSE_WAL_SIZE}}'
          delete-sts: 'true'
      - name: Weaviate v1.24.x - check additional and old data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py
      - name: Weaviate preview image - upgrade K8s from none-raft to Raft version
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.PERSISTENCE_MAX_REUSE_WAL_SIZE=${{env.PERSISTENCE_MAX_REUSE_WAL_SIZE}}'
          delete-sts: 'true'
      - name: Weaviate preview image - check additional and old data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py
      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: upgrade-journey-raft-${{ inputs.lsm_access_strategy }}-logs
          path: apps/upgrade-journey-raft/logs/
  upgrade-journey-raft-1_30:
    needs: [newer-or-equal-than-1_30]
    if: ${{ (needs.newer-or-equal-than-1_30.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'upgrade-journey-raft-1_30' || github.event.inputs.test_to_run == '')}}
    name: Upgrade to Raft journey e2e test v1.30
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      WEAVIATE_NON_RAFT_VERSION: 1.24.15
      WEAVIATE_RAFT_VERSION_1: 1.25.0
      WEAVIATE_RAFT_VERSION_1_29: 1.29.0
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Install python dependencies
        run: |
          cd apps/upgrade-journey-raft
          pip3 install -r requirements.txt
      - name: Weaviate v1.24.x - setup K8s 3-node cluster
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'setup'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_NON_RAFT_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set podManagementPolicy=OrderedReady --set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
      - name: Weaviate v1.24.x - import data
        run: |
          cd apps/upgrade-journey-raft
          python3 run.py
      - name: Weaviate v1.24.x - check data after import
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py
      - name: Weaviate v1.25.0 - upgrade K8s cluster from non-raft to Raft version
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_RAFT_VERSION_1}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
          delete-sts: 'true'
      - name: Weaviate v1.25.0 - check data after upgrade to Raft version
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py
      - name: Weaviate v1.29.0 image - upgrade K8s from Raft to another Raft version (rolling update)
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_RAFT_VERSION_1_29}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
      - name: Weaviate v1.29.0 image - check old data
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py
      - name: Weaviate v1.29.0 image - add additional data and check all (old and new) data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_run.py
          python3 additional_checks.py
      - name: Weaviate v1.29.0 image - sync with schema V1
        run: |
          if [ "$(curl -X POST -s -o /dev/null -w "%{http_code}" localhost:8080/v1/cluster/schema-v1)" != "200" ]; then
            echo "Synchronization of schema V1 failed"
            exit 1
          else
            echo "Schema V1 succesfully synchronized"
          fi
      - name: Weaviate v1.24.x - downgrade from Raft to none-raft version
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_NON_RAFT_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set podManagementPolicy=OrderedReady  --set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
          delete-sts: 'true'
      - name: Weaviate v1.24.x - check additional and old data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py
      - name: Weaviate v1.29.0 image - upgrade K8s from none-raft to Raft version
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_RAFT_VERSION_1_29}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
          delete-sts: 'true'
      - name: Weaviate preview image - check additional and old data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py
      - name: Weaviate preview image - upgrade from v1.29.0 to preview image (rolling update)
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
      - name: Weaviate preview image - check additional and old data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py
      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: upgrade-journey-raft-${{ inputs.lsm_access_strategy }}-logs
          path: apps/upgrade-journey-raft/logs/
  upgrade-journey-raft-metadata-only-voters:
    needs: [newer-or-equal-than-1_25]
    if: ${{ (needs.newer-or-equal-than-1_25.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'upgrade-journey-raft-metadata-only-voters' || github.event.inputs.test_to_run == '') }}
    name: Upgrade to Raft journey e2e test with metadata only voters
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      WEAVIATE_RAFT_VERSION_1: 1.25.0
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Install python dependencies
        run: |
          cd apps/upgrade-journey-raft
          pip3 install -r requirements.txt
      - name: Weaviate v1.25 with metadata only voters setting - setup K8s 6-node cluster
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'setup'
          workers: '1'
          replicas: '5'
          weaviate-version: ${{env.WEAVIATE_RAFT_VERSION_1}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.RAFT_METADATA_ONLY_VOTERS=true --set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
      - name: Weaviate v1.25 with metadata only voters setting - import data and additional data
        run: |
          cd apps/upgrade-journey-raft
          python3 run.py
          python3 additional_run.py
      - name: Weaviate v1.25 with metadata only voters setting - check if data has been saved only in non-voter nodes
        run: |
          cd apps/upgrade-journey-raft
          ./scripts/metadata_only_voters_check.sh
      - name: Weaviate preview image - upgrade K8s from Raft to another Raft version (rolling update)
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '5'
          weaviate-version: ${{env.WEAVIATE_VERSION}}
          modules: 'text2vec-contextionary'
          values-inline: '--set env.RAFT_METADATA_ONLY_VOTERS=true --set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}}'
      - name: Weaviate preview image with metadata only voters setting - check if data has been saved only in non-voter nodes
        run: |
          cd apps/upgrade-journey-raft
          ./scripts/metadata_only_voters_check.sh
      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: upgrade-journey-raft-metadata-only-voters-${{ inputs.lsm_access_strategy }}-logs
          path: apps/upgrade-journey-raft/logs/
  rbac-upgrade-journey:
    needs: [real-version-in-tag, newer-or-equal-than-1_30]
    if: ${{ (needs.newer-or-equal-than-1_30.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'rbac-upgrade-journey' || github.event.inputs.test_to_run == '')}}
    name: RBAC upgrade journey e2e test
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      WEAVIATE_API_KEY: "admin-key"
      WEAVIATE_API_KEY_CUSTOM: "custom-key"
      RBAC_CONFIG: /tmp/rbac_config.yaml
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      # Get previous minor version for standard upgrade/downgrade
      # BEAWARE: This action sets up its own Python environment, so we need to install dependencies again.
      # Run it before installing dependencies.
      - name: Get Previous Minor Version
        id: get_previous
        uses: weaviate/github-common-actions/.github/actions/get-previous-version@djanicek/auth-get-version
        with:
          weaviate_version: ${{ needs.real-version-in-tag.outputs.real_version }}
          jump_type: 'minor'
          jumps: '1'
          gh_token: ${{ secrets.GITHUB_TOKEN }}
      - name: Set WEAVIATE_INITIAL_VERSION environment variable
        run: |
          echo "WEAVIATE_INITIAL_VERSION=${{ steps.get_previous.outputs.previous_version }}" >> $GITHUB_ENV
      - name: Install python dependencies
        run: |
          cd apps/rbac-upgrade-journey
          pip3 install --ignore-installed  -r requirements.txt
      - name: Generate RBAC config file
        run: |
          cat > ${{ env.RBAC_CONFIG }} << 'EOF'
          authentication:
            anonymous_access:
              enabled: false
            apikey:
              enabled: true
              allowed_keys:
              - ${{ env.WEAVIATE_API_KEY }}
              - ${{ env.WEAVIATE_API_KEY_CUSTOM }}
              users:
              - admin-user
              - custom-user
          authorization:
            admin_list:
              enabled: false
            rbac:
              enabled: true
              root_users:
                - admin-user
          EOF
      - name: Weaviate ${{env.WEAVIATE_INITIAL_VERSION}} - setup K8s 3-node cluster with low RAFT snapshot threshold
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'setup'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_INITIAL_VERSION}}
          modules: 'text2vec-contextionary'
          rbac: 'true'
          auth-config: ${{ env.RBAC_CONFIG }}
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.RAFT_SNAPSHOT_THRESHOLD=2'
      - name: Weaviate ${{env.WEAVIATE_INITIAL_VERSION}} - create roles
        run: |
          cd apps/rbac-upgrade-journey
          python3 create_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Weaviate ${{env.WEAVIATE_INITIAL_VERSION}} - import data
        run: |
          cd apps/upgrade-journey-raft
          python3 run.py --api-key ${{ env.WEAVIATE_API_KEY_CUSTOM}}
      - name: Weaviate ${{env.WEAVIATE_INITIAL_VERSION}} - check roles
        run: |
          cd apps/rbac-upgrade-journey
          python3 check_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Generate RBAC with dynamic user management
        run: |
          cat > ${{ env.RBAC_CONFIG }} << 'EOF'
          authentication:
            anonymous_access:
              enabled: false
            apikey:
              enabled: true
              allowed_keys:
              - ${{ env.WEAVIATE_API_KEY }}
              - ${{ env.WEAVIATE_API_KEY_CUSTOM }}
              users:
              - admin-user
              - custom-user
            db_users:
              enabled: true
          authorization:
            admin_list:
              enabled: false
            rbac:
              enabled: true
              root_users:
                - admin-user
          EOF
      - name: Weaviate ${{env.WEAVIATE_VERSION}} - upgrade K8s cluster and enable dynamic user management
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_VERSION}}
          modules: 'text2vec-contextionary'
          rbac: 'true'
          auth-config: ${{ env.RBAC_CONFIG }}
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.RAFT_SNAPSHOT_THRESHOLD=2'
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - check data after upgrade
        run: |
          cd apps/upgrade-journey-raft
          python3 checks.py --api-key ${{ env.WEAVIATE_API_KEY_CUSTOM}}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - check roles
        run: |
          cd apps/rbac-upgrade-journey
          python3 check_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - add additional data and check all (old and new) data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_run.py --api-key ${{ env.WEAVIATE_API_KEY_CUSTOM}}
          python3 additional_checks.py --api-key ${{ env.WEAVIATE_API_KEY_CUSTOM}}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - add additional roles and check all (old and new) roles
        run: |
          cd apps/rbac-upgrade-journey
          python3 additional_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
          python3 additional_check_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - sync with schema V1
        run: |
          if [ "$(curl -X POST -H "Authorization: Bearer ${{ env.WEAVIATE_API_KEY}}" -s -o /dev/null -w "%{http_code}" localhost:8080/v1/cluster/schema-v1)" != "200" ]; then
            echo "Synchronization of schema V1 failed"
            exit 1
          else
            echo "Schema V1 succesfully synchronized"
          fi
      - name: Weaviate ${{env.WEAVIATE_VERSION}} - create users and check that they exist
        run: |
          cd apps/rbac-upgrade-journey
          python3 create_users.py --api-key ${{ env.WEAVIATE_API_KEY }}
          python3 check_users.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - perform a rolling restart
        run: |
          cd apps/rbac-upgrade-journey
          ./scripts/restart_and_wait.sh
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - check roles after rolling restart
        run: |
          cd apps/rbac-upgrade-journey
          python3 additional_check_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - check users after rolling restart
        run: |
          cd apps/rbac-upgrade-journey
          python3 check_users.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Weaviate ${{ env.WEAVIATE_VERSION}} - check data after rolling restart
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py --api-key ${{ env.WEAVIATE_API_KEY_CUSTOM}}
      - name: Generate RBAC config file
        run: |
          cat > ${{ env.RBAC_CONFIG }} << 'EOF'
          authentication:
            anonymous_access:
              enabled: false
            apikey:
              enabled: true
              allowed_keys:
              - ${{ env.WEAVIATE_API_KEY }}
              - ${{ env.WEAVIATE_API_KEY_CUSTOM }}
              users:
              - admin-user
              - custom-user
          authorization:
            admin_list:
              enabled: false
            rbac:
              enabled: true
              root_users:
                - admin-user
          EOF
      - name: Weaviate ${{ env.WEAVIATE_INITIAL_VERSION}} - downgrade back to ${{ env.WEAVIATE_INITIAL_VERSION}}
        uses: weaviate/weaviate-local-k8s@v2
        with:
          operation: 'upgrade'
          workers: '1'
          replicas: '3'
          weaviate-version: ${{env.WEAVIATE_INITIAL_VERSION}}
          modules: 'text2vec-contextionary'
          rbac: 'true'
          auth-config: ${{ env.RBAC_CONFIG }}
          values-inline: '--set env.PERSISTENCE_LSM_ACCESS_STRATEGY=${{env.PERSISTENCE_LSM_ACCESS_STRATEGY}} --set env.RAFT_SNAPSHOT_THRESHOLD=2'
      - name: Weaviate ${{ env.WEAVIATE_INITIAL_VERSION}} - check additional and old data
        run: |
          cd apps/upgrade-journey-raft
          python3 additional_checks.py --api-key ${{ env.WEAVIATE_API_KEY_CUSTOM}}
      - name: Weaviate ${{ env.WEAVIATE_INITIAL_VERSION}} - check roles after downgrade
        run: |
          cd apps/rbac-upgrade-journey
          python3 additional_check_roles.py --api-key ${{ env.WEAVIATE_API_KEY }}
      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rbac-upgrade-journey-${{ inputs.lsm_access_strategy }}-logs
          path: apps/upgrade-journey-raft/logs/
  async-repair:
    # CONTEXT: https://github.com/weaviate/weaviate/issues/5229
    needs: [newer-or-equal-than-1_26]
    if: ${{ (needs.newer-or-equal-than-1_26.outputs.check == 'true') && ( github.event.inputs.test_to_run == 'async-repair' || github.event.inputs.test_to_run == '') }}
    name: Chaos pipeline to ensure asynchronous replication repairs what read-repair can't yet
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./async_repair.sh
  update-stability:
    name: Recall Stability on object updates
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.test_to_run == 'update-stability' || github.event.inputs.test_to_run == '' }}
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      PROMETHEUS_MONITORING_ENABLED: "true"
      DATASET: "dbpedia-100k-openai-ada002-angular"
      DISTANCE: "cosine"
      INDEX_TYPE: "hnsw"
      UPDATE_PERCENTAGE: "0.08"
      CLEANUP_INTERVAL_SECONDS: "30"
      UPDATE_ITERATIONS: "10"
      REQUIRED_RECALL: "0.992"
    steps:
      - uses: actions/checkout@v3
      # - name: Polar Signals Continuous Profiling
      #   uses: polarsignals/gh-actions-ps-profiling@v0.0.1
      #   with:
      #     polarsignals_cloud_token: ${{ secrets.POLARSIGNALS_TOKEN }}
      #     labels: 'job=${{ github.job }};gh_run_id=${{ github.run_id }}'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./update_stability.sh
  debug-reindexing-endpoint-journey-tests:
    needs: [newer-or-equal-than-1_24]
    if: ${{ (needs.newer-or-equal-than-1_24.outputs.check == 'true') && (github.event.inputs.test_to_run == 'debug-reindexing-endpoint-journey-tests' || github.event.inputs.test_to_run == '' )}}
    name: Debug reindexing endpoint journey tests
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.22'
      - name: Run reindexing chaos tests
        run: |
          ./debug-reindexing.sh
  upgrade-journey-object-nested-properties:
    needs: [newer-or-equal-than-1_26]
    if: ${{ (needs.newer-or-equal-than-1_26.outputs.check == 'true') && (github.event.inputs.test_to_run == 'upgrade-journey-object-nested-properties' || github.event.inputs.test_to_run == '' )}}
    name: Upgrade journey nested properties
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.22'
      - name: Run upgrade journey object nested properties tests
        run: |
          ./upgrade_journey_object_nested_properties.sh
  compaction-optimization:
    needs: [newer-or-equal-than-1_24]
    if: ${{ (needs.newer-or-equal-than-1_24.outputs.check == 'true') && (github.event.inputs.test_to_run == 'compaction-optimization' || github.event.inputs.test_to_run == '' ) }}
    name: Check that compaction doesn't get stuck
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.22'
      - name: Run compaction-optimization chaos tests
        run: |
          ./compaction_optimization.sh
  downgrade-journey-raft-schema:
    needs: [newer-or-equal-than-1_28]
    name: Downgrade journey Raft schema - single node
    if: ${{ (needs.newer-or-equal-than-1_28.outputs.check == 'true') && (github.event.inputs.test_to_run == 'downgrade-journey-raft-schema' || github.event.inputs.test_to_run == '' ) }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      MINIMUM_WEAVIATE_VERSION: 1.25.0
      NUM_NODES: 1
    steps:
      - uses: actions/checkout@v3
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.24'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./downgrade_journey_raft_schema.sh
  downgrade-journey-raft-schema-cluster:
    needs: [newer-or-equal-than-1_28]
    name: Downgrade journey Raft schema - cluster
    if: ${{ (needs.newer-or-equal-than-1_28.outputs.check == 'true') && (github.event.inputs.test_to_run == 'downgrade-journey-raft-schema-cluster' || github.event.inputs.test_to_run == '' ) }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
      MINIMUM_WEAVIATE_VERSION: 1.25.0
      NUM_NODES: 3
    steps:
      - uses: actions/checkout@v3
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.24'
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Run chaos test
        run: ./downgrade_journey_raft_schema.sh

  tombstones-cleanup-while-crash:
    needs: [newer-or-equal-than-1_28]
    if: ${{ (needs.newer-or-equal-than-1_28.outputs.check == 'true') && (github.event.inputs.test_to_run == 'tombstones-cleanup-while-crash' || github.event.inputs.test_to_run == '' ) }}
    name: Check that tombstone cleanup works while crashes happen
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.22'
      - name: Run tombstones-cleanup-while-crash chaos tests
        run: |
          ./tombstones_cleanup_while_crash.sh

  hnsw-snapshotting-while-crash:
    needs: [newer-or-equal-than-1_31]
    if: ${{ (needs.newer-or-equal-than-1_31.outputs.check == 'true') && (github.event.inputs.test_to_run == 'hnsw-snapshotting-while-crash' || github.event.inputs.test_to_run == '' ) }}
    name: Check that HNSW snapshotting works while crashes happen
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      PERSISTENCE_LSM_ACCESS_STRATEGY: ${{inputs.lsm_access_strategy}}
    steps:
      - uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.22'
      - name: Run hnsw-snapshotting-while-crash chaos tests
        run: |
          ./hnsw_snapshotting_while_crash.sh